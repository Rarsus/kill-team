ai = {import:ai-text-plugin}
commentsPlugin = {import:comments-plugin}
fullscreenButton = {import:fullscreen-button-plugin}

// Constants for action option length limits
MAX_ACTION_LENGTH = 100

// Helper function to sanitize HTML and prevent XSS
sanitizeHTML(str) =>
  if(!str) return "";
  let div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;

// Helper function to sanitize and normalize story log text
sanitizeStoryLog(text) =>
  if(!text) return "";
  // Remove triple-hyphens used in prompt templates
  text = text.replaceAll("\n---\n", "\n").replaceAll("\n---", "");
  // Normalize numbered lists to hyphens
  text = text.replace(/\n[0-9]\. /g, "\n- ");
  text = text.replace(/$1\. /g, "");
  // Remove AI formatting variations
  text = text.replace(/\nAlternatively, you could choose to:\n/, "\n");
  text = text.replace(/\nOr, you could:\n/, "\n");
  // Fix missing Option 3 prefix
  text = text.replace(/(Option 2:[^\n]+)\nAlternatively, you could /, "$1\nOption 3: Alternatively, you could ");
  // Normalize option formatting
  text = text.replace("Here are 3 possible actions that you could take next:", "");
  text = text.replace(/Option ([0-9]): (You could|Or, you could|Alternatively, you could)/g, "Option $1: You");
  // Remove excessive newlines
  text = text.replace(/\n{3,}/g, "\n\n");
  return text;

// Helper function to save story to localStorage with error handling
saveStoryLog(text) =>
  try {
    localStorage.storyLog = text;
  } catch(e) {
    console.error("Failed to save story log to localStorage:", e);
    showErrorMessage("Warning: Unable to save progress. Your browser may have localStorage disabled.");
  }

// Helper function to truncate action text with ellipsis
truncateAction(action) =>
  if(!action) return "";
  let text = action.trim();
  if(text.length > MAX_ACTION_LENGTH) {
    return text.substring(0, MAX_ACTION_LENGTH - 3) + "...";
  }
  return text;

// Helper function to show error messages to the user
showErrorMessage(message) =>
  if(outputEl) {
    let errorDiv = document.createElement("div");
    errorDiv.style.cssText = "color: #ff4444; background: #fff0f0; padding: 0.5rem; margin: 0.5rem 0; border-radius: 3px; border-left: 3px solid #ff4444;";
    errorDiv.textContent = message;
    outputEl.prepend(errorDiv);
  }

// Helper function to validate custom action input
validateCustomAction(action) =>
  if(!action || typeof action !== 'string') {
    return { valid: false, error: "Please enter an action." };
  }
  let trimmed = action.trim();
  if(trimmed.length === 0) {
    return { valid: false, error: "Action cannot be empty." };
  }
  if(trimmed.length < 3) {
    return { valid: false, error: "Action is too short. Please be more descriptive." };
  }
  if(trimmed.length > 500) {
    return { valid: false, error: "Action is too long. Please keep it under 500 characters." };
  }
  return { valid: true, action: trimmed };
  
// storyPrompt 
//   instruction
//     [firstInstruction]  ^[storyLogEl.value.trim() === ""]
//     [storyContinuationInstruction] ^[storyLogEl.value.trim() !== ""]
//   startWith
//     You, the player, are ^[storyLogEl.value.trim() === ""]
//     [""]^[storyLogEl.value.trim() !== ""]
//   stopSequences
//     Which action do you choose?
//   onStart(obj) =>
//     window.storyLogBeforeStarting = storyLogEl.value; // we save this in case we need to try again due to an error, or whatever (see onFinish)
//     loadingEl.innerHTML = obj.loadingIndicatorHtml;
//     outputEl.innerHTML = "";
//     backBtn.disabled = true;
//     regenerateBtn.disabled = true;
//   onChunk(data) =>
//     storyLogEl.value += data.textChunk;
//     storyLogEl.scrollTop = storyLogEl.scrollHeight; // scroll to the bottom of the story log as the chunks come in
//     outputEl.innerHTML += data.textChunk;
//   onFinish(data) =>
//     storyLogEl.value = sanitizeStoryLog(storyLogEl.value);
//     saveStoryLog(storyLogEl.value);
//     renderCurrentSituation();
//     if(data.stopReason === "error") {
//       showErrorMessage("An error occurred while generating the story. Please try again.");
//       backBtn.click();
//     }
//     backBtn.disabled = false;
//     regenerateBtn.disabled = false;
//     startOverBtn.style.display = "";

executeAction(action, opts) =>
  if(!opts) opts = {};
  
  // Validate custom actions
  if(opts.isCustom) {
    let validation = validateCustomAction(action);
    if(!validation.valid) {
      showErrorMessage(validation.error);
      return;
    }
    action = validation.action;
    storyLogEl.value += `\n\nPLAYER ACTION (custom): ${action}\n\n`; 
  } else {
    storyLogEl.value += `\n\nPLAYER ACTION: ${action}\n\n`; 
  }
  generate();

// Helper function to initialize generation state
initializeGenerationState() =>
  let state = {
    pendingObj: null,
    actionsPendingObj: null,
    stop: false
  };
  
  let finishGeneration = () => {
    startOverBtn.style.display = "";
    loadingEl.innerHTML = "";
    stopNoticeEl.style.visibility = "hidden";
  };
  
  window.currentGenerateController = {
    stop: function() {
      state.stop = true;
      finishGeneration();
      if(state.pendingObj) state.pendingObj.stop();
      if(state.actionsPendingObj) state.actionsPendingObj.stop();
    },
  };
  
  return { state, finishGeneration };

// Helper function to setup UI for generation
setupGenerationUI() =>
  backBtn.disabled = true;
  regenerateBtn.disabled = true;
  outputEl.innerHTML = "";
  
  // Show stop notice after a delay to prevent double clicks
  setTimeout(() => {
    stopNoticeEl.style.visibility = "visible";
    backBtn.disabled = false;
    regenerateBtn.disabled = false;
  }, 3000);

// Helper function to generate story continuation
async generateStoryContinuation(state) =>
  let stopDueToNewlines = false;
  let isFirstGeneration = storyLogEl.value.trim() === "";
  
  state.pendingObj = ai({
    instruction: isFirstGeneration ? firstInstruction : storyContinuationInstruction,
    startWith: isFirstGeneration ? "You, the player, are" : "",
    onChunk: (data) => {
      if(stopDueToNewlines) return;
      
      // Stop if too many newlines (indicates AI is done with the paragraph)
      if([...data.fullTextSoFar.matchAll(/\n+/g)].length >= 3) {
        state.pendingObj.stop();
        stopDueToNewlines = true;
      }
      
      storyLogEl.value += data.textChunk;
      storyLogEl.scrollTop = storyLogEl.scrollHeight;
      outputEl.innerHTML += data.textChunk;
    },
  });
  
  // Show loading indicator after a brief delay
  setTimeout(() => {
    loadingEl.innerHTML = state.pendingObj.loadingIndicatorHtml; 
  }, 10);
  
  let data = await state.pendingObj.onFinishPromise;
  
  if(!state.stop) {
    storyLogEl.value = sanitizeStoryLog(storyLogEl.value);
    saveStoryLog(storyLogEl.value);
    
    if(data.stopReason === "error") {
      showErrorMessage("Failed to generate story continuation. Please try again.");
    }
  }
  
  return state.stop;

// Helper function to generate action options
async generateActionOptions(state) =>
  outputEl.innerHTML += "\n\n";
  
  state.actionsPendingObj = ai({ 
    instruction: actionOptionsInstruction,
    startWith: "Here are 3 possible actions that you could take next:\nOption 1: You could choose to",
    onChunk: (data) => {
      storyLogEl.value += data.textChunk;
      storyLogEl.scrollTop = storyLogEl.scrollHeight;
      outputEl.innerHTML += data.textChunk;
    },
    stopSequences: ["Which action do you choose?", "Which option do you choose?"],
  });
  
  let actionsData = await state.actionsPendingObj.onFinishPromise;
  
  if(!state.stop) {
    storyLogEl.value = sanitizeStoryLog(storyLogEl.value);
    saveStoryLog(storyLogEl.value);
    
    if(actionsData.stopReason === "error") {
      showErrorMessage("Failed to generate action options. Please try again.");
    }
  }
  
  return state.stop;

// Main generate function - orchestrates story and action generation
async generate() =>
  window.storyLogTextBeforeLastSituationGenerated = storyLogEl.value;
  
  let { state, finishGeneration } = initializeGenerationState();
  setupGenerationUI();
  
  try {
    // Generate story continuation
    let stopped = await generateStoryContinuation(state);
    if(stopped) return;
    
    // Generate action options
    stopped = await generateActionOptions(state);
    if(stopped) return;
    
    // Render the complete situation
    renderCurrentSituation();
  } catch(error) {
    console.error("Generation error:", error);
    showErrorMessage("An unexpected error occurred. Please try regenerating.");
  } finally {
    finishGeneration();
  }
  
  
  
  
  
  
handleRegenButtonClick() =>
  if(window.currentGenerateController) {
    window.currentGenerateController.stop();
    stopNoticeEl.style.visibility = "hidden";
  }
  
  if(window.storyLogTextBeforeLastSituationGenerated) {
    storyLogEl.value = window.storyLogTextBeforeLastSituationGenerated;
  } else {
    // Remove all lines after the last player action
    let lines = storyLogEl.value.split("\n");
    while(lines.length > 0) {
      let lastLine = lines.pop();
      if(lastLine.startsWith("PLAYER ACTION")) {
        lines.push(lastLine);
        break;
      }
    }
    storyLogEl.value = lines.join("\n") + "\n\n";
  }
  
  generate();

// Helper function to create action button HTML with sanitization
createActionButton(actionText) =>
  let sanitized = sanitizeHTML(actionText);
  let truncated = truncateAction(actionText);
  let displayText = sanitizeHTML(truncated);
  
  return `<div class="action-item" style="margin-top:0.5rem; display:flex;"><span style="margin-right:0.25rem; background:var(--box-color); padding:0.25rem; border-radius:3px; flex-grow:1;">${displayText}</span><button style="min-width:max-content; max-width:max-content;" data-action="${sanitized}" onclick="executeAction(this.dataset.action);">do this</button></div>`;

// Helper function to render story paragraph with edit button
renderStoryParagraph(paragraphText) =>
  let storyParagraphDiv = document.createElement("div");
  storyParagraphDiv.style.position = "relative";
  storyParagraphDiv.id = "storyParagraphDiv";
  
  // Safely format quoted text with emphasis
  let formattedText = paragraphText.replace(/"(.*?)"/g, (match, p1) => {
    let sanitized = sanitizeHTML(p1);
    return `<i style="opacity:0.6;">"${sanitized}"</i>`;
  });
  
  storyParagraphDiv.innerHTML = formattedText;
  
  // Add edit button
  let editButton = document.createElement("button");
  editButton.onclick = function() {
    storyParagraphEdit();
  };
  editButton.style.cssText = "font-size: 80%; margin-left: 0.25rem;";
  editButton.textContent = "edit";
  storyParagraphDiv.append(editButton);
  
  return storyParagraphDiv;

// Helper function to render custom action input
renderCustomActionInput(customActionPrefill) =>
  let customActionDiv = document.createElement("div");
  let prefillValue = sanitizeHTML(customActionPrefill || "");
  
  customActionDiv.innerHTML = `<div class="action-item" style="margin-top:0.5rem; display:flex;"><span style="margin-right:0.25rem; background:var(--box-color); padding:0.25rem; border-radius:3px; flex-grow:1;"><input onkeydown="if(event.which === 13) { event.preventDefault(); customActionDoItBtn.click(); }" style="width:100%;" id="customActionInputEl" placeholder="Type a custom action..." value="${prefillValue}"></span><button id="customActionDoItBtn" style="min-width:max-content; max-width:max-content;" onclick="executeAction(customActionInputEl.value, {isCustom:true});">do this</button></div>`;
  
  return customActionDiv;

// Helper function to extract current situation text from story log
extractCurrentSituation() =>
  let parts = storyLogEl.value.split(/(PLAYER ACTION.+)/);
  let filtered = parts.filter(t => !t.startsWith("PLAYER ACTION:"));
  return filtered.pop() || "";

// Main render function - displays current story situation and action options
renderCurrentSituation(opts) => 
  if(!opts) opts = {};
  
  // Handle empty story log - show start screen
  if(storyLogEl.value.trim() === "") {
    outputEl.innerHTML = "";
    startCtn.style.display = "";
    topButtonsCtn.style.display = "none";
    return;
  }
  
  topButtonsCtn.style.display = "";
  loadingEl.innerHTML = "";
  
  // Clean up any incomplete player action markers
  if(storyLogEl.value.trim().endsWith("PLAYER ACTION:")) {
    storyLogEl.value = storyLogEl.value.trim().replace(/PLAYER ACTION:$/m, "").trim();
  }
  
  // Extract and prepare current situation text
  let currentSituationText = extractCurrentSituation();
  currentSituationText = currentSituationText.replace(/\n+/g, "\n").trim();
  
  // Split into story paragraph and action options
  let parts = currentSituationText.split(/\nOption [0-9]:/);
  let storyText = parts[0] || "";
  
  // Clear output and render story paragraph
  outputEl.innerHTML = "";
  if(storyText) {
    let storyParagraphDiv = renderStoryParagraph(storyText);
    outputEl.append(storyParagraphDiv);
  }
  
  // Render action buttons
  let actionMatches = [...currentSituationText.matchAll(/\nOption [0-9]: ?(.+)/g)];
  actionMatches.forEach(match => {
    let actionText = match[1].trim();
    let actionButtonHTML = createActionButton(actionText);
    let tempDiv = document.createElement("div");
    tempDiv.innerHTML = actionButtonHTML;
    outputEl.append(tempDiv.firstChild);
  });
  
  // Add custom action input
  let customActionDiv = renderCustomActionInput(opts.customActionPrefill);
  outputEl.append(customActionDiv);
  
  // Show the 'full story logs' button
  storyLogBtn.style.display = '';



async storyParagraphEdit() =>
  let editResolver;

  storyParagraphDiv.style.minHeight = "7rem";

  let textareaWrapper = document.createElement("div");
  textareaWrapper.style.cssText = "position:absolute; top:0; bottom:0; left:0; right:0;";

  let textarea = document.createElement("textarea");
  textarea.style.cssText = "width:100%; height:100%; outline:none;";
  
  let parts1 = storyLogEl.value.split("PLAYER ACTION:").pop().split("\n\n");
  let originalText = "";
  if(parts1.length === 1) originalText = parts1[0]; // `parts1.length === 1` will be true if this is the intro paragraph
  else originalText = parts1.slice(1).join("\n\n").split("\nOption 1:")[0];
  
  textarea.value = originalText;

  textareaWrapper.append(textarea);
  storyParagraphDiv.append(textareaWrapper);

  textarea.focus();

  textarea.onchange = async function() {
    await new Promise(r => setTimeout(r, 300)); // delay needed for textarea blur to trigger properly
    editResolver(textarea.value);
  };
  
  function clickAnywhereHandler(e) {
    if(e.target !== textarea) editResolver(textarea.value);
  }
  
  window.addEventListener("mousedown", clickAnywhereHandler); // mousedown rather than click else click-and-drag to highlight that ends outside of the textarea will trigger it
  
  let newText = await new Promise(resolve => {
    editResolver = resolve;
  });
  
  window.removeEventListener("mousedown", clickAnywhereHandler);

  textareaWrapper.remove();

  storyLogEl.value = storyLogEl.value.replace(originalText, newText);
  saveStoryLog(storyLogEl.value);
  
  renderCurrentSituation();


handleBackButtonClick() =>
  if(window.currentGenerateController) {
    window.currentGenerateController.stop();
    stopNoticeEl.style.visibility = "hidden";
  }
  
  let parts = storyLogEl.value.split("PLAYER ACTION");
  storyLogEl.value = parts.slice(0, -1).join("PLAYER ACTION").trim();
  
  let lastPart = parts[parts.length-1];
  let customActionPrefill = null;
  if(lastPart.trim().startsWith("(custom):")) {
    customActionPrefill = lastPart.split("\n")[0].replace("(custom):", "").trim();
  }
  
  regenerateBtn.disabled = true;
  saveStoryLog(storyLogEl.value);
  renderCurrentSituation({customActionPrefill});


replaceLast(str, search, replacement) =>
  let pos = str.lastIndexOf(search);
  if (pos === -1) return str;
  return str.slice(0, pos) + replacement + str.slice(pos + search.length);

getFormattedStoryLogs() =>
  let text = storyLogEl.value.trim(); 
  // this removes all the historical 'options' from the story, since the AI doesn't need to see the non-chosen options
  text = text.split("\n").filter(l => !/^Option [0-9]:.+/.test(l)).join("\n");
  text = text.replace(/\n\nPLAYER ACTION: ?/g, "\n\n");
  // if the most recent action was a custom action, then we use all caps for it to draw attention to it and show that it's not meant to be "high quality writing"
  let lines = text.trim().split("\n");
  if(lines.at(-1).startsWith("PLAYER ACTION (custom):")) {
    lines[lines.length-1] = lines[lines.length-1].replace(/PLAYER ACTION \(custom\): ?/g, "PLAYER ACTION: "); // NOTE: if you change the wording here, you need to also change the ternary conditionals in `storyContinuationInstruction`
    text = lines.join("\n");
  }
  // and for all other custom actions we just add "> " added to the start so we don't draw too much attention to them
  text = text.replace(/\n\nPLAYER ACTION \(custom\): ?/g, "\n\n> ");
  text = text.replace(/Which (action|option) (do|will) you choose\?/g, "");
  text = text.replace(/\n{3,}/g, "\n\n");
  return text.trim();
  
  
  
firstInstruction
  Your task as the game master is to write the opening paragraph of a text adventure story based on the following description/idea:
  [adventureDescriptionEl.value.trim() || `A fun, interesting, creative, and engaging adventure.`]
  [""]
  This is the opening paragraph - the spark that should elicit fascination within the player's imagination. It should be interesting, authentic, descriptive, natural, engaging, and creative. Paint a vivid picture with sensory details and set the tone for an exciting adventure. Make the player curious about what happens next.
  $output = [this.joinItems("\n")]
  
  
storyContinuationInstruction
  [this.latestLogs = getFormattedStoryLogs(), ""]Your task as the game master is to write the next paragraph in the following story, based on the most recent events[this.latestLogs.includes("PLAYER ACTION:") ? ` and the "PLAYER ACTION"` : ""]. You must write ONE paragraph only. The paragraph you write should just give the consequences of the player's last action. Write in a clean, crisp, and engaging dungeon master / storytelling style.
  [""]
  # Story So Far:
  [this.latestLogs]
  [""]
  ---
  That's the story so far. Write the next paragraph of this captivating story. This is a never-ending adventure story - do not try to "wrap up" the story. You must pay attention to the most recent [this.latestLogs.includes("PLAYER ACTION:") ? `"PLAYER ACTION"` : "action that the player took"], shown above.
  The player provided these writing instructions: [writingInstructionsEl.value.trim() || "Be creative."]
  Remember, you must write exactly ONE paragraph in your response. Write in a clean, crisp, and engaging style. Be specific and concrete with consequences. Show, don't tell.
  $output = [this.joinItems("\n")]
  
  
actionOptionsInstruction
  Your task as the game master is to write 3 options for what the player might like to do next in the following story. Give 3 interesting, engaging, and creative choices, that you think the player would *love* (based on what you notice about their past actions) and then end your response with "Which action do you choose?"
  This story is based on the following initial prompt:
  [""]
  # Initial Story Prompt:
  [adventureDescriptionEl.value || `A fun, interesting, creative, and engaging adventure.`]
  \n
  # Story So Far:
  [getFormattedStoryLogs()]
  [""]
  ---
  [""]
  That's the story so far. Pay attention to the most recent events (at the end), since you need to come up with 3 possible actions that the player could take next. Try to write actions that you think the player would *love*, based on their previous actions.
  Avoid unnecessary repetition of previous story elements.
  The player provided these writing instructions: [writingInstructionsEl.value.trim() || "Be creative!"]
  The action choices must be interesting, short (under 100 characters), and varied. Your goal is to try to guess at actions that the player might like to take based on their past actions. Try to cater to the player's evident play-style and desires. Make each option distinct - one bold/aggressive, one cautious/thoughtful, and one creative/unexpected.
  Your response MUST follow the following template:\n
  ---
  Here are 3 possible actions that you could take next:
  Option 1: You could \[...\]
  Option 2: Or, you could \[...\]
  Option 3: Alternatively, you could \[...\]
  Which action do you choose?
  ---\n
  You MUST write your response using the above template. Just give ideas for *actions* that could be taken - not consequences. Keep each action concise and under 100 characters. Remember to add the question "Which action do you choose?" after the 3 possible actions.
  $output = [this.joinItems("\n")]

$meta
  title = AI Text Adventure - free, no-signup, no limits - AI Dungeon Alternative
  description = An AI roleplay text adventure game, where you can create your own online AI game/scenario, explore the world, make choices in a choose-your-own-adventure style, kind of like an alternative to AI Dungeon - an AI story game. Completely free, no sign-up, no restrictions on daily usage/credits.
  
bannedUserIds
  6d406d216527af6ab87a
  